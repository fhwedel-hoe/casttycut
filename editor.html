<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>asciinema Editor</title>
    <link rel="stylesheet" href="css/min.css" />
    <script src="js/min.js"></script>
    <script>
function init() {
  let xmlns = "http://www.w3.org/2000/svg";
  let dom_timeline = document.getElementById('timeline');
  let dom_terminal = document.getElementById('terminal');
  let dom_frame_index = document.getElementById('event_index');
  let dom_audio = document.getElementById('audio');
  var dom_current_indicator;
  var terminal;
  var events;
  
  function collapse_events(stdout) {
    let out = [];
    let i = 0;
    out.push(stdout[i]);
    i++;
    while (stdout.length > i) {
      if (stdout[i].time_delta == 0) {
        out[out.length-1].bytes += stdout[i].bytes;
      } else {
        out.push(stdout[i]);
      }
      i++;
    }
    if (stdout.length >= out.length) {
      console.log(`Compressed ${stdout.length} events into ${out.length}.`);
    }
    return out;
  }
  
  function stretch_events(stdout, duration) {
    let events_duration = stdout[stdout.length-1].time_absolute;
    let total_padding = duration-events_duration;
    let event_padding = total_padding/stdout.length;
    stdout.forEach((e, i) => {
      e.time_absolute += event_padding*(i+1);
    });
    return stdout;
  }
  
  function step_to(event_index) {
    dom_frame_index.value = event_index;
    terminal.write(events.stdout[event_index].bytes);
  }

  /*
  * Jumps to the specified index:
  * From current index, searches events backwards for an independent event,
  * resets the terminal, jumps to that event steps forwards until the specified index is reached
  * possibly plays the whole recording again
  */
  // "\u001b[H" move to home
  // "\u001b]0" could be a reset
  function jump_to(event_index) {
    let current_index = dom_frame_index.valueAsNumber;
    let first_independent_index = event_index;
    while (first_independent_index > 0 
      && ! RegExp('\\u001b\\]0|\\u001b\\[H').test(events.stdout[first_independent_index].bytes)
    ) {
      first_independent_index -= 1;
    }
    if (first_independent_index < 0) {
      first_independent_index = 0;
    }
    terminal.reset();
    terminal.clear();
    for (let i = first_independent_index; i <= event_index; i++) {
      step_to(i);
    }
  }

  document.getElementById('event_next').addEventListener("click", e => {
    step_to(dom_frame_index.valueAsNumber+1);
    dom_audio.currentTime = events.stdout[dom_frame_index.valueAsNumber].time_absolute;
  }, false);

  dom_frame_index.addEventListener('change', e => {
    jump_to(dom_frame_index.valueAsNumber);
    dom_audio.currentTime = events.stdout[dom_frame_index.valueAsNumber].time_absolute;
  }, false);
  
  function add_indicator(time_seconds) {
    let path = document.createElementNS(xmlns, 'path');
    path.setAttributeNS(null, 'd', `M ${time_seconds} 0 V 1`);
    dom_timeline.appendChild(path);
    return path;
  }
  
  function add_marker(time_seconds, event_index) {
    let marker = add_indicator(time_seconds);
    marker.addEventListener('click', e => {
      if (dom_audio.paused) {
        jump_to(event_index);
      }
      dom_audio.currentTime = events.stdout[event_index].time_absolute;
    }, false);
  }

  function initialize_ui() {
    dom_terminal.style.width = `${events.width+7}ex`; // TODO: detect width properly
    //dom_terminal.style.height = `${events.height*2.13}ex`;
    
    terminal = new Terminal({
      rows: events.height,
      cols: events.width
    });
    terminal.open(dom_terminal);
    
    dom_timeline.setAttributeNS(null, 'viewBox', `0 0 ${events.duration} 1`);
    events.stdout.forEach((e, i) => {
      add_marker(e.time_absolute, i)
    });
    
    dom_frame_index.max = events.stdout.length - 1;
    
    dom_current_indicator = add_indicator(0);
    dom_current_indicator.style.stroke = "silver";
    
    jump_to(0);
  }
  
  function raise_events_v1(stdout) {
    high_stdout = stdout.map(e => { return {
      time_delta : e[0],
      bytes : e[1]
    }});
    let time_absolute = 0;
    high_stdout.forEach(e => {
      time_absolute += e.time_delta;
      e.time_absolute = time_absolute;
    });
    return high_stdout;
  }
  
  function raise_events_v2(events) {
    high_events = events.map(e => { return {
      time_absolute : e[0],
      bytes : e[2]
    }});
    return high_events;
  }
  
  dom_audio.addEventListener('timeupdate', e => {
    dom_current_indicator.setAttributeNS(null, 'd', `M ${dom_audio.currentTime} 0 V 1`);
    if (events.stdout[dom_frame_index.valueAsNumber].time_absolute > dom_audio.currentTime) {
      let index = events.stdout.findIndex(e => e.time_absolute < dom_audio.currentTime);
      jump_to(index);
    }
    while (events.stdout[dom_frame_index.valueAsNumber+1].time_absolute < dom_audio.currentTime) {
      step_to(dom_frame_index.valueAsNumber+1);
    }
  });
  
  let title = window.location.hash.substring(1);
  if (! title) {
    window.location.replace("index.html");
  }
  document.title = title;
  let prefix = "casts/"+title;
  
  dom_audio.src = prefix+'/audio.mp3'
  fetch(prefix+'/events.cast').then((response) => {
    return response.text();
  }).then((data) => {
    
    try {
      events = JSON.parse(data);
      events.stdout = raise_events_v1(events.stdout);
      events.stdout = collapse_events(events.stdout);
      events.stdout = stretch_events(events.stdout, dom_audio.duration);
    } catch (e) {
      if (e instanceof SyntaxError) {
        let lines = data.split('\n');
        events = JSON.parse(lines.shift());
        events.stdout = JSON.parse("[" + lines.join(",") + "]");
        if (!Array.isArray(events.stdout[events.stdout.length-1])) {
          let footer = events.stdout.pop();
          Object.assign(events,footer);
        }
        events.stdout = raise_events_v2(events.stdout);
        if (!events.duration) {
          events.duration = events.stdout[events.stdout.length-1].time_absolute;
        }
      } else {
        throw e;
      }
    }
    initialize_ui();
  });
}
    </script>
    <style>
#timeline {
  border: 1px solid black;
  width: 100%;
  height: 2em;
}
#timeline path {
  stroke: #000;
}
#timeline path:hover {
  stroke: red;
}
#terminal {
  margin: 0 auto;
  /*border: 1px solid red;*/
}
.xterm-viewport {
  overflow: hidden;
}
#audio {
  display: block;
  width: 100%;
}
#event_index {
  width: 8ex;
}
    </style>
  </head>
  <body onload="init();">
    <div id="terminal"></div>
    <div>&nbsp;</div>
    <svg id="timeline" preserveAspectRatio="none"></svg>
    <div id="controls"><label>Current event: <input type="number" id="event_index" min="0" value="0"></label> <button id="event_next">→</button></div>
    <audio id="audio" controls="controls"></audio>
    <div style="text-align: center;">Bitte auf den ▶ Button drücken.</div>
  </body>
</html>
